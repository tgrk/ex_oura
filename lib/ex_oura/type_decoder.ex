defmodule ExOura.TypeDecoder do
  @moduledoc """
  Decodes HTTP response bodies based on operation type specifications.

  This module handles the conversion of raw JSON responses from the Oura API into properly
  typed Elixir data structures. It supports various type conversions including dates,
  timestamps, unions, and complex nested structures generated by the OpenAPI code generator.

  ## Key Features

  - **Date/DateTime Parsing**: Automatically converts ISO8601 date and datetime strings
  - **Struct Creation**: Builds proper structs from generated OpenAPI client modules
  - **Union Type Handling**: Resolves union types based on actual data
  - **Nested Object Support**: Recursively processes nested objects and lists
  - **Null Safety**: Handles optional/nullable fields gracefully

  ## Type Conversion Rules

  - String dates (YYYY-MM-DD) → `Date` structs
  - ISO8601 timestamps → `DateTime` structs
  - Nested objects → Module structs (when available)
  - Lists → Recursively processed lists
  - Union types → Resolved based on data type

  ## Usage

  This module is used internally by the ExOura client and typically doesn't need to be
  called directly. The Client module automatically uses this to decode API responses.

  ## Examples

      # Internal usage by Client
      operation = %{response: %{200 => {MyModule, :t}}}
      {:ok, decoded} = TypeDecoder.decode_response(200, json_body, operation)
  """

  @doc """
  Decodes an HTTP response body based on the operation's type specifications.

  Takes the HTTP status code, response body, and operation metadata to determine
  the appropriate type conversion and decode the response into proper Elixir data structures.

  ## Parameters

  - `status` - HTTP status code from the response
  - `body` - Raw response body (typically parsed JSON)
  - `operation` - Operation metadata containing response type specifications

  ## Returns

  - `{:ok, decoded_data}` - Successfully decoded response
  - `{:error, :unable_to_decode}` - When type information is missing or invalid

  ## Type Resolution

  The function looks up the expected response type based on:
  1. The HTTP status code
  2. The operation's response type mapping
  3. Applies appropriate type conversions

  ## Examples

      # Decode a successful response
      operation = %{response: %{200 => {MyModule, :t}}}
      {:ok, result} = decode_response(200, %{field: "value"}, operation)

      # Handle unknown response types
      {:error, :unable_to_decode} = decode_response(200, body, %{})

  """
  @spec decode_response(status :: pos_integer(), body :: term(), operation :: map()) ::
          {:ok, term()} | {:error, :unable_to_decode}
  def decode_response(200 = _status, [], _operation), do: {:ok, []}

  def decode_response(status, body, operation) do
    case get_type(operation, status) do
      {:ok, response_type} ->
        {:ok, decode(body, response_type)}

      {:error, :unable_to_decode} = error ->
        error
    end
  end

  # Private functions for type resolution and decoding

  defp get_type(%{response: response} = _operation, status) do
    case response |> Map.new() |> Map.get(status, nil) do
      [{_response_type, :t}] = type ->
        {:ok, type}

      {_response_type, :t} = type ->
        {:ok, type}

      _unexpected ->
        {:error, :unable_to_decode}
    end
  end

  # Core decoding functions

  defp decode(nil, _response_type), do: nil
  defp decode(value, {:string, :date}), do: Date.from_iso8601!(value)
  defp decode(value, {:union, types}), do: decode(value, union(value, types))

  defp decode(value, [type]), do: Enum.map(value, &decode(&1, type))

  defp decode(%{} = value, {module, type}) do
    base = prepare_base(module)
    fields = module.__fields__(type)

    for {field_name, field_type} <- fields, reduce: base do
      decoded_value ->
        case Map.get(value, field_name) do
          nil ->
            decoded_value

          field_value ->
            Map.put(decoded_value, field_name, decode(field_value, field_type))
        end
    end
  end

  # Timestamp handling for modules ending with "Timestamp"
  defp decode(value, {type, :t}) do
    with true <- type |> to_string() |> String.ends_with?("Timestamp"),
         {:ok, dt, _} <- DateTime.from_iso8601(value) do
      dt
    else
      _error ->
        value
    end
  end

  # Generic string handling with smart date/datetime parsing
  defp decode(value, {:string, :generic}) when is_binary(value) do
    # Try to parse as date if it looks like a date string (YYYY-MM-DD format)
    case Date.from_iso8601(value) do
      {:ok, date} ->
        date

      _error ->
        # Try to parse as datetime if it looks like an ISO8601 string
        case DateTime.from_iso8601(value) do
          {:ok, dt, _} -> dt
          _error -> value
        end
    end
  end

  defp decode(value, _type), do: value

  # Helper to prepare base struct or map
  defp prepare_base(module) do
    Code.ensure_loaded(module)

    if function_exported?(module, :__struct__, 0) do
      struct(module)
    else
      %{}
    end
  end

  # Union type resolution logic
  defp union(_value, [type, :null]), do: type
  defp union(value, [:number, {:string, :generic}]) when is_number(value), do: :number
  defp union(_value, [:number, {:string, :generic}]), do: :string
  defp union(value, [:integer, {:string, :generic}]) when is_number(value), do: :integer
  defp union(_value, [:integer, {:string, :generic}]), do: :string

  defp union(_value, types) do
    raise "TypedDecoder: Unable to decode union type #{inspect(types)}"
  end
end
